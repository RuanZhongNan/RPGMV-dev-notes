(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{451:function(a,s,t){"use strict";t.r(s);var v=t(8),n=Object(v.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"属于游戏前端而不是单纯的网页应用前端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属于游戏前端而不是单纯的网页应用前端"}},[a._v("#")]),a._v(" 属于游戏前端而不是单纯的网页应用前端")]),a._v(" "),t("p",[a._v("“mv”，“mv项目”指的是由RPGMV生成的基于JavaScript ES5版本的 桌面应用端/移动端 项目。这个定位相当于“游戏前端”而不是常见的“网页前端”。这两个前端有交集，就是html的基础。游戏前端主要用的是canvas标签，而网页前端主要使用的是HTML5+CSS3+JavaScript6的前端三剑客，和相关的Ajax、Vue等框架。这些框架和mv项目基本上无关。")]),a._v(" "),t("p",[a._v("（笔者当时花了好多时间才搞清楚mv项目的具体定位和学习方向，走了很多弯路。）")]),a._v(" "),t("h2",{attrs:{id:"属于pixi-js-canvas的技术栈-而不是单纯的html-canvas的技术栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属于pixi-js-canvas的技术栈-而不是单纯的html-canvas的技术栈"}},[a._v("#")]),a._v(" 属于pixi.js+canvas的技术栈，而不是单纯的html+canvas的技术栈")]),a._v(" "),t("p",[a._v("mv项目是用pixi.js的API来实现canvas绘图的，而不是用html5提供的canvas标签API来绘图的。因此，大部分的canvas教程，都不能很好地契合我们的mv项目，因为大部分的canvas教程一定会涉及到html标签的其他写法，而mv项目几乎不是用其他多余的html标签。这事实上造成了技术栈的割裂。")]),a._v(" "),t("h2",{attrs:{id:"以canvas为主体的mv项目在技术栈上的窘境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#以canvas为主体的mv项目在技术栈上的窘境"}},[a._v("#")]),a._v(" 以canvas为主体的mv项目在技术栈上的窘境")]),a._v(" "),t("p",[a._v("使用纯canvas作为游戏的技术栈，就意味着，无法使用html+css的方式来做动画效果，也无法使用DOM元素的API，自然也无法使用基于DOM对象的大部分框架，甚至连最繁琐的，原生的JavaScript动态效果都是用不了。\n这意味着，我们要在canvas标签内部实现完几乎全部已经成熟的功能，诸如鼠标点击事件，意味着我们要重复造轮子。")])])}),[],!1,null,null,null);s.default=n.exports}}]);