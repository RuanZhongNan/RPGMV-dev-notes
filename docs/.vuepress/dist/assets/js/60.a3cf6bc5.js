(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{633:function(a,v,s){"use strict";s.r(v);var t=s(9),c=Object(t.a)({},(function(){var a=this,v=a.$createElement,s=a._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"属于游戏前端而不是单纯的网页应用前端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#属于游戏前端而不是单纯的网页应用前端"}},[a._v("#")]),a._v(" 属于游戏前端而不是单纯的网页应用前端")]),a._v(" "),s("p",[s("strong",[a._v("mv")]),a._v("，"),s("strong",[a._v("mv项目")]),a._v("指的是由RPGMV生成的基于JavaScript ES5版本的 桌面应用端/移动端 项目。这个定位相当于“游戏前端”而不是常见的“网页前端”。这两个前端有交集，就是html的基础。游戏前端主要用的是canvas标签，而网页前端主要使用的是HTML5+CSS3+JavaScript6的前端三剑客，和相关的Ajax、Vue等框架。这些框架和mv项目基本上无关。")]),a._v(" "),s("p",[a._v("（笔者当时花了好多时间才搞清楚mv项目的具体定位和学习方向，走了很多弯路。）")]),a._v(" "),s("h2",{attrs:{id:"属于pixi-js-canvas的技术栈-而不是单纯的html-canvas的技术栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#属于pixi-js-canvas的技术栈-而不是单纯的html-canvas的技术栈"}},[a._v("#")]),a._v(" 属于pixi.js+canvas的技术栈，而不是单纯的html+canvas的技术栈")]),a._v(" "),s("p",[a._v("mv项目是用pixi.js的API来实现"),s("code",[a._v("canvas")]),a._v("绘图的，而不是用"),s("code",[a._v("html5")]),a._v("提供的"),s("code",[a._v("canvas")]),a._v("标签"),s("code",[a._v("API")]),a._v("来绘图的。因此，大部分的canvas教程，都不能很好地契合我们的mv项目，因为大部分的"),s("code",[a._v("canvas")]),a._v("教程一定会涉及到"),s("code",[a._v("html")]),a._v("标签的其他写法，而mv项目几乎不是用其他多余的html标签。这事实上造成了技术栈的割裂。")]),a._v(" "),s("h2",{attrs:{id:"以canvas为主体的mv项目在技术栈上的窘境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以canvas为主体的mv项目在技术栈上的窘境"}},[a._v("#")]),a._v(" 以canvas为主体的mv项目在技术栈上的窘境")]),a._v(" "),s("p",[a._v("使用纯canvas作为游戏的技术栈，就意味着，无法使用html+css的方式来做动画效果，也无法使用DOM元素的API，自然也无法使用基于DOM对象的大部分框架，甚至连最繁琐的，原生的JavaScript动态效果都是用不了。\n这意味着，我们要在canvas标签内部实现完几乎全部已经成熟的功能，诸如鼠标点击事件，意味着我们要重复造轮子。")])])}),[],!1,null,null,null);v.default=c.exports}}]);