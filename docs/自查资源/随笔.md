---
title: 随笔
date: 2022-04-22 09:00:25
permalink: /pages/8febd8/
categories:
  - 自查资源
tags:
  - 
---


# 随笔
此部分内容是作者临时为了展示内容而编纂的，不一定具有参考意义。

## 判断敌人是否有某状态？

### 需求
Q: 研究了一晚上也没能把判断敌人是否有x状态这个jio本给整出来，放弃，摆烂，睡觉


### 可能的解决方案
```isStateAffected```函数


### 确定数据存储位置
```$gameTroop```用于保存敌人的数据，在```DataManager```内定义实例。

```js
DataManager.createGameObjects = function () {
	//$gameTemp         = 新 游戏临时()
	$gameTemp = new Game_Temp();
	//$gameSystem       = 新 游戏系统()
	$gameSystem = new Game_System();
	//$gameScreen       = 新 游戏画面()
	$gameScreen = new Game_Screen();
	//$gameTimer        = 新 游戏计时()
	$gameTimer = new Game_Timer();
	//$gameMessage      = 新 游戏消息()
	$gameMessage = new Game_Message();
	//$gameSwitches     = 新 游戏开关组()
	$gameSwitches = new Game_Switches();
	//$gameVariables    = 新 游戏变量组()
	$gameVariables = new Game_Variables();
	//$gameSelfSwitches = 新 游戏独立开关组()
	$gameSelfSwitches = new Game_SelfSwitches();
	//$gameActors       = 新 游戏角色组()
	$gameActors = new Game_Actors();
	//$gameParty        = 新 游戏队伍()
	$gameParty = new Game_Party();
	//$gameTroop        = 新 游戏敌群()
	$gameTroop = new Game_Troop();
	//$gameMap          = 新 游戏地图()
	$gameMap = new Game_Map();
	//$gamePlayer       = 新 游戏角色()
	$gamePlayer = new Game_Player();
};
```






### 确定敌人数组
敌人的数组在```Game_Troop```的```setup```方法内定义，用```members```方法返回其数组。

#### 定义
```js
//安装
Game_Troop.prototype.setup = function (troopId) {
	//清除()
	this.clear();
	//敌群id = troopId//敌群id
	this._troopId = troopId;
	//敌人组 = []
	this._enemies = [];
	//敌群() 成员组 对每一个 方法(成员)
	this.troop().members.forEach(function (member) {
		//如果 ( 数据敌人组[成员 敌人id])
		if ($dataEnemies[member.enemyId]) {
			//敌人id = 成员 敌人id
			var enemyId = member.enemyId;
			//x = 成员 x 
			var x = member.x;
			//y = 成员 y
			var y = member.y;
			//敌人 = 新 游戏敌人(敌人id , x , y)
			var enemy = new Game_Enemy(enemyId, x, y);
			//如果(成员 隐藏)
			if (member.hidden) {
				//敌人 隐藏()
				enemy.hide();
			}
			//敌人组 添加(敌人)
			this._enemies.push(enemy);
		}
		//this
	}, this);
	//制作唯一名称()
	this.makeUniqueNames();
};
```

#### 获取
```js
//成员组
Game_Troop.prototype.members = function () {
	//返回 敌人组
	return this._enemies;
};
```



### 翻找对象的父类
每一个敌人都是```Game_Enemy```类的实例对象。
```js
var enemy = new Game_Enemy(enemyId, x, y);
```

```Game_Enemy```类继承了```Game_Battler```类。
```js
//设置原形 
Game_Enemy.prototype = Object.create(Game_Battler.prototype);
//设置创造者
Game_Enemy.prototype.constructor = Game_Enemy;
//初始化
Game_Enemy.prototype.initialize = function (enemyId, x, y) {
	//游戏战斗者 初始化 呼叫(this)
	Game_Battler.prototype.initialize.call(this);
	//安装(敌人id ,x,y)
	this.setup(enemyId, x, y);
};
```



```Game_Battler```类继承了```Game_BattlerBase```类。
```js
function Game_Battler() {
    this.initialize.apply(this, arguments);
}

//设置原形 
Game_Battler.prototype = Object.create(Game_BattlerBase.prototype);
//设置创造者
Game_Battler.prototype.constructor = Game_Battler;
//初始化
Game_Battler.prototype.initialize = function() {
    Game_BattlerBase.prototype.initialize.call(this);
};
```



```Game_BattlerBase```类提供了```isStateAffected```方法
```js
//是状态影响
Game_BattlerBase.prototype.isStateAffected = function (stateId) {
	//返回 状态组 包含 ( 状态id )
	return this._states.contains(stateId);
};
```




### 



























